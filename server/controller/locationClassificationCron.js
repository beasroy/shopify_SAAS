import cron from 'node-cron';
import { cityClassificationQueue } from '../config/shopifyQueues.js';
import Order from '../models/Order.js';
import CityMetadata from '../models/CityMetadata.js';


export const setupLocationClassificationCron = () => {
    cron.schedule('0 6 * * *', async () => {
        console.log('üîÑ [Cron] Starting daily city classification job...');
        
        try {
            const now = new Date();
            const yesterdayStart = new Date(now);
            yesterdayStart.setDate(yesterdayStart.getDate() - 1);
            yesterdayStart.setHours(0, 0, 0, 0);
            
            const yesterdayEnd = new Date(now);
            yesterdayEnd.setDate(yesterdayEnd.getDate() - 1);
            yesterdayEnd.setHours(23, 59, 59, 999);
            
            console.log(`üìÖ [Cron] Checking orders from ${yesterdayStart.toISOString()} to ${yesterdayEnd.toISOString()} (yesterday only)`);
            
           
            const unknownCities = await Order.aggregate([
                {
                    $match: {
                        orderCreatedAt: {
                            $gte: yesterdayStart,
                            $lte: yesterdayEnd
                        },
                        city: { $exists: true, $ne: null, $nin: [null, ''] },
                        state: { $exists: true, $ne: null, $nin: [null, ''] }
                    }
                },
                {
                    $group: {
                        _id: {
                            city: { $toLower: { $trim: { input: "$city" }}},
                            state: { $toLower: { $trim: { input: "$state" }}}
                        },
                        originalCity: { $first: "$city" },
                        originalState: { $first: "$state" }
                    }
                },
                {
                    $project: {
                        _id: 0,
                        cityNormalized: "$_id.city",
                        city: "$originalCity",
                        state: "$originalState"
                        // Note: lookupKey will be generated by GPT/worker with country
                    }
                }
            ]);
            
            if (unknownCities.length === 0) {
                console.log('‚úÖ [Cron] No cities found in yesterday\'s orders');
                return;
            }
            
            console.log(`üìä [Cron] Found ${unknownCities.length} unique city/state combinations from yesterday`);
            
            // 2. Check which cities are already in CityMetadata (match on city+state since country is dynamic)
            // Use aggregation to efficiently get unique city+state combinations
            const existing = await CityMetadata.aggregate([
                {
                    $group: {
                        _id: {
                            cityNormalized: { $toLower: "$cityNormalized" },
                            state: { $toLower: "$state" }
                        }
                    }
                },
                {
                    $project: {
                        _id: 0,
                        key: { 
                            $concat: [
                                "$_id.cityNormalized", 
                                "_", 
                                "$_id.state"
                            ] 
                        }
                    }
                }
            ]);
            
            const existingCityStateSet = new Set(existing.map(c => c.key));
            
            // 3. Filter out already classified cities
            const newCities = unknownCities.filter(c => {
                const cityStateKey = `${c.cityNormalized}_${(c.state || '').toLowerCase().trim()}`;
                return !existingCityStateSet.has(cityStateKey);
            });
            
            if (newCities.length === 0) {
                console.log('‚úÖ [Cron] All cities already classified');
                return;
            }
            
            console.log(`üÜï [Cron] Found ${newCities.length} new cities to classify`);
            
            // 4. Batch cities (20 per GPT call)
            const batchSize = 20;
            const batches = [];
            
            for (let i = 0; i < newCities.length; i += batchSize) {
                batches.push(newCities.slice(i, i + batchSize));
            }
            
            console.log(`üì¶ [Cron] Creating ${batches.length} batch jobs`);
            
            // 5. Queue batch jobs
            const jobPromises = batches.map((batch, index) => {
                return cityClassificationQueue.add('classify-cities-batch', {
                    type: 'batch',
                    cities: batch,
                    batchNumber: index + 1,
                    totalBatches: batches.length
                }, {
                    priority: 1, // Normal priority for cron jobs
                    attempts: 3,
                    backoff: {
                        type: 'exponential',
                        delay: 2000
                    }
                });
            });
            
            await Promise.all(jobPromises);
            
            console.log(`‚úÖ [Cron] Queued ${batches.length} batch jobs for city classification`);
            
        } catch (error) {
            console.error('‚ùå [Cron] Error in city classification job:', error);
        }
    }, { timezone: 'UTC' });
    
    console.log('‚úÖ [Cron] Daily city classification cron scheduled (6 AM UTC)');
};

