import dotenv from 'dotenv';
import { fileURLToPath } from 'node:url';
import { dirname, join } from 'node:path';
import { connectDB } from '../config/db.js';
import { cityClassificationQueue } from '../config/shopifyQueues.js';
import Order from '../models/Order.js';
import CityMetadata from '../models/CityMetadata.js';
import { acquireLock, releaseLock } from '../utils/lockUtils.js';

// Get the directory of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load .env file from server directory (parent of scripts directory)
dotenv.config({ path: join(__dirname, '..', '.env') });

/**
 * One-time script to backfill CityMetadata for all existing cities in Orders
 * Usage: node server/scripts/backfillCityMetadata.js
 */
async function backfillCityMetadata() {
    const lockKey = 'backfill-city-metadata';
    let lockAcquired = false;
    
    try {
        console.log('üîÑ Starting city metadata backfill...');
        
        // Check if backfill is already running
        const lockAcquiredResult = await acquireLock(lockKey, 7200); // 2 hour TTL
        if (!lockAcquiredResult) {
            console.log('‚ö†Ô∏è  Backfill is already running. Exiting...');
            process.exit(0);
        }
        lockAcquired = true;
        console.log('‚úÖ Acquired lock for backfill process');
        
        // Connect to database
        if (!process.env.MONGO_URI && !process.env.MONGODB_URI) {
            console.error('‚ùå Error: MongoDB connection string not found!');
            console.error('   Please set either MONGO_URI or MONGODB_URI in your .env file');
            console.error('   Example: MONGO_URI=mongodb://localhost:27017/your_database');
            process.exit(1);
        }
        
        // Use MONGODB_URI if MONGO_URI is not set (for compatibility)
        if (!process.env.MONGO_URI && process.env.MONGODB_URI) {
            process.env.MONGO_URI = process.env.MONGODB_URI;
        }
        
        await connectDB();
        console.log('‚úÖ Connected to database');
        
        // Get all unique city/state from Orders
        console.log('üìä Fetching all unique cities from Orders...');
        const allCities = await Order.aggregate([
            {
                $match: {
                    city: { $exists: true, $ne: null, $ne: '' },
                    state: { $exists: true, $ne: null, $ne: '' }
                }
            },
            {
                $group: {
                    _id: {
                        city: { $toLower: { $trim: { input: "$city" }}},
                        state: { $toLower: { $trim: { input: "$state" }}}
                    },
                    originalCity: { $first: "$city" },
                    originalState: { $first: "$state" }
                }
            },
            {
                $project: {
                    _id: 0,
                    cityNormalized: "$_id.city",
                    city: "$originalCity",
                    state: "$originalState"
                    // Note: lookupKey will be generated by GPT/worker with country
                }
            }
        ]);
        
        console.log(`üìä Found ${allCities.length} unique cities`);
        
        if (allCities.length === 0) {
            console.log('‚ÑπÔ∏è  No cities found in Orders table');
            process.exit(0);
        }
        
        // Check existing cities by cityNormalized + state (since lookupKey includes country from GPT)
        // Use aggregation to efficiently get unique city+state combinations
        const existing = await CityMetadata.aggregate([
            {
                $group: {
                    _id: {
                        cityNormalized: { $toLower: "$cityNormalized" },
                        state: { $toLower: "$state" }
                    }
                }
            },
            {
                $project: {
                    _id: 0,
                    key: { 
                        $concat: [
                            "$_id.cityNormalized", 
                            "_", 
                            "$_id.state"
                        ] 
                    }
                }
            }
        ]);
        
        const existingCityStateSet = new Set(existing.map(c => c.key));
        
        const newCities = allCities.filter(c => {
            const cityStateKey = `${c.cityNormalized}_${(c.state || '').toLowerCase().trim()}`;
            return !existingCityStateSet.has(cityStateKey);
        });
        console.log(`üÜï ${newCities.length} new cities to classify (${allCities.length - newCities.length} already exist)`);
        
        if (newCities.length === 0) {
            console.log('‚úÖ All cities already classified');
            process.exit(0);
        }
        
        // Queue batch jobs
        const batchSize = 20;
        let batchNumber = 1;
        const totalBatches = Math.ceil(newCities.length / batchSize);
        
        console.log(`üì¶ Creating ${totalBatches} batch jobs...`);
        
        for (let i = 0; i < newCities.length; i += batchSize) {
            const batch = newCities.slice(i, i + batchSize);
            
            await cityClassificationQueue.add('classify-cities-batch', {
                type: 'batch',
                cities: batch,
                batchNumber: batchNumber++,
                totalBatches: totalBatches
            }, {
                priority: 1,
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 2000
                }
            });
            
            console.log(`‚úÖ Queued batch ${batchNumber - 1}/${totalBatches} (${batch.length} cities)`);
        }
        
        console.log(`\n‚úÖ Backfill complete! Queued ${totalBatches} batch jobs`);
        console.log('‚ÑπÔ∏è  Monitor the queue to see job progress');
        
        // Wait a bit to ensure jobs are queued
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Release lock before exiting
        if (lockAcquired) {
            await releaseLock(lockKey);
            console.log('‚úÖ Released backfill lock');
        }
        
        process.exit(0);
        
    } catch (error) {
        console.error('‚ùå Error during backfill:', error);
        
        // Release lock on error
        if (lockAcquired) {
            await releaseLock(lockKey);
            console.log('‚úÖ Released backfill lock after error');
        }
        
        process.exit(1);
    }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    backfillCityMetadata();
}

export default backfillCityMetadata;

