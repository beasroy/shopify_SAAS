import dotenv from 'dotenv';
import { fileURLToPath } from 'node:url';
import { dirname, join } from 'node:path';
import { connectDB } from '../config/db.js';
import { cityClassificationQueue } from '../config/shopifyQueues.js';
import Order from '../models/Order.js';
import CityMetadata from '../models/CityMetadata.js';
import { acquireLock, releaseLock } from '../utils/lockUtils.js';

// Get the directory of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load .env file from server directory (parent of scripts directory)
dotenv.config({ path: join(__dirname, '..', '.env') });

/**
 * One-time script to backfill CityMetadata for all existing cities in Orders
 * Usage: node server/scripts/backfillCityMetadata.js
 */
async function backfillCityMetadata() {
    const lockKey = 'backfill-city-metadata';
    let lockAcquired = false;
    
    try {
        console.log('üîÑ Starting city metadata backfill...');
        
        // Check if backfill is already running
        const lockAcquiredResult = await acquireLock(lockKey, 7200); // 2 hour TTL
        if (!lockAcquiredResult) {
            console.log('‚ö†Ô∏è  Backfill is already running. Exiting...');
            process.exit(0);
        }
        lockAcquired = true;
        console.log('‚úÖ Acquired lock for backfill process');
        
        // Connect to database
        if (!process.env.MONGO_URI && !process.env.MONGODB_URI) {
            console.error('‚ùå Error: MongoDB connection string not found!');
            console.error('   Please set either MONGO_URI or MONGODB_URI in your .env file');
            console.error('   Example: MONGO_URI=mongodb://localhost:27017/your_database');
            process.exit(1);
        }
        
        // Use MONGODB_URI if MONGO_URI is not set (for compatibility)
        if (!process.env.MONGO_URI && process.env.MONGODB_URI) {
            process.env.MONGO_URI = process.env.MONGODB_URI;
        }
        
        await connectDB();
        console.log('‚úÖ Connected to database');
        
        // Get all unique city/state from Orders
        console.log('üìä Fetching all unique cities from Orders...');
        const allCities = await Order.aggregate([
            {
                $match: {
                    city: { $exists: true, $ne: null, $ne: '' },
                    state: { $exists: true, $ne: null, $ne: '' }
                }
            },
            {
                $group: {
                    _id: {
                        city: { $toLower: { $trim: { input: "$city" }}},
                        state: { $toLower: { $trim: { input: "$state" }}}
                    },
                    originalCity: { $first: "$city" },
                    originalState: { $first: "$state" }
                }
            },
            {
                $project: {
                    _id: 0,
                    cityNormalized: "$_id.city",
                    city: "$originalCity",
                    state: "$originalState"
                    // Note: lookupKey will be generated by GPT/worker with country
                }
            }
        ]);
        
        console.log(`üìä Found ${allCities.length} unique cities`);
        
        if (allCities.length === 0) {
            console.log('‚ÑπÔ∏è  No cities found in Orders table');
            process.exit(0);
        }
        
        // Check existing cities by cityNormalized + state (since lookupKey includes country from GPT)
        // Use aggregation to efficiently get unique city+state combinations
        const existing = await CityMetadata.aggregate([
            {
                $group: {
                    _id: {
                        cityNormalized: { $toLower: "$cityNormalized" },
                        state: { $toLower: "$state" }
                    }
                }
            },
            {
                $project: {
                    _id: 0,
                    key: { 
                        $concat: [
                            "$_id.cityNormalized", 
                            "_", 
                            "$_id.state"
                        ] 
                    }
                }
            }
        ]);
        
        const existingCityStateSet = new Set(existing.map(c => c.key));
        
        const newCities = allCities.filter(c => {
            const cityStateKey = `${c.cityNormalized}_${(c.state || '').toLowerCase().trim()}`;
            return !existingCityStateSet.has(cityStateKey);
        });
        console.log(`üÜï ${newCities.length} new cities to classify (${allCities.length - newCities.length} already exist)`);
        
        if (newCities.length === 0) {
            console.log('‚úÖ All cities already classified');
            process.exit(0);
        }
        
        // Ensure Redis connection is established before queueing
        console.log('üîå Verifying Redis connection...');
        try {
            const queueConnection = cityClassificationQueue.opts.connection;
            
            // Test connection by trying to ping Redis
            if (queueConnection) {
                try {
                    await queueConnection.ping();
                    console.log('   ‚úÖ Redis connection verified (ping successful)');
                } catch (pingError) {
                    // If ping fails, try to connect
                    console.log('   Attempting to connect to Redis...');
                    if (queueConnection.status !== 'ready' && queueConnection.status !== 'connecting') {
                        await queueConnection.connect();
                    }
                    // Wait a bit for connection to establish
                    await new Promise(resolve => setTimeout(resolve, 500));
                    // Try ping again
                    await queueConnection.ping();
                    console.log('   ‚úÖ Redis connected and verified');
                }
            } else {
                throw new Error('No Redis connection found in queue configuration');
            }
        } catch (error) {
            console.error('   ‚ùå Failed to connect to Redis:', error.message);
            console.error('   Stack:', error.stack);
            throw new Error(`Redis connection failed: ${error.message}`);
        }
        
        // Ensure Redis connection is ready before queuing
        const queueConnection = cityClassificationQueue.opts.connection;
        if (queueConnection.status !== 'ready') {
            console.log('   Ensuring Redis connection is ready...');
            await queueConnection.connect();
            // Wait for connection to be fully ready
            let attempts = 0;
            while (queueConnection.status !== 'ready' && attempts < 10) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            if (queueConnection.status !== 'ready') {
                throw new Error('Redis connection failed to become ready');
            }
            console.log('   ‚úÖ Redis connection ready');
        }
        
        // Queue batch jobs
        const batchSize = 20;
        let batchNumber = 1;
        const totalBatches = Math.ceil(newCities.length / batchSize);
        
        console.log(`üì¶ Creating ${totalBatches} batch jobs...`);
        
        let successCount = 0;
        let errorCount = 0;
        const queuedJobIds = [];
        
        for (let i = 0; i < newCities.length; i += batchSize) {
            const batch = newCities.slice(i, i + batchSize);
            
            try {
                // Add job with explicit jobId to ensure it's tracked
                const job = await cityClassificationQueue.add('classify-cities-batch', {
                    type: 'batch',
                    cities: batch,
                    batchNumber: batchNumber++,
                    totalBatches: totalBatches
                }, {
                    priority: 1,
                    attempts: 3,
                    backoff: {
                        type: 'exponential',
                        delay: 2000
                    },
                    // Clean up jobs after processing to prevent Redis OOM
                    // Keep completed jobs for 1 hour for monitoring, then auto-clean
                    removeOnComplete: {
                        age: 3600, // 1 hour
                        count: 500 // Keep max 500 completed jobs
                    },
                    // Keep failed jobs for 24 hours for debugging
                    removeOnFail: {
                        age: 86400, // 24 hours
                        count: 100 // Keep max 100 failed jobs
                    }
                });
                
                if (job && job.id) {
                    queuedJobIds.push(job.id);
                    
                    // Wait a bit longer to ensure job is persisted
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Verify job was actually persisted by trying to get it back
                    try {
                        const verifyJob = await cityClassificationQueue.getJob(job.id);
                        if (verifyJob && verifyJob.id) {
                            console.log(`‚úÖ Queued batch ${batchNumber - 1}/${totalBatches} (${batch.length} cities) - Job ID: ${job.id} [verified in Redis]`);
                            successCount++;
                        } else {
                            console.error(`‚ö†Ô∏è  Queued batch ${batchNumber - 1}/${totalBatches} but job not found in Redis - Job ID: ${job.id}`);
                            console.error(`   This indicates the job was created but not persisted to Redis`);
                            errorCount++;
                        }
                    } catch (verifyError) {
                        console.error(`‚ö†Ô∏è  Error verifying job ${job.id}:`, verifyError.message);
                        console.log(`‚úÖ Queued batch ${batchNumber - 1}/${totalBatches} (${batch.length} cities) - Job ID: ${job.id} [verification failed]`);
                        successCount++; // Count as success since we got a job ID
                    }
                } else {
                    console.error(`‚ùå Failed to queue batch ${batchNumber - 1}/${totalBatches} - No job ID returned`);
                    errorCount++;
                }
            } catch (error) {
                console.error(`‚ùå Error queueing batch ${batchNumber - 1}/${totalBatches}:`, error.message);
                if (error.stack) {
                    console.error(`   Stack:`, error.stack);
                }
                errorCount++;
            }
        }
        
        if (errorCount > 0) {
            console.log(`\n‚ö†Ô∏è  Warning: ${errorCount} batches failed to queue (${successCount} succeeded)`);
        }
        
        console.log(`\n‚úÖ Backfill complete! Queued ${successCount}/${totalBatches} batch jobs successfully`);
        if (errorCount > 0) {
            console.log(`‚ö†Ô∏è  ${errorCount} batches failed to queue`);
        }
        console.log('‚ÑπÔ∏è  Monitor the queue to see job progress');
        
        // Wait a bit to ensure jobs are queued, then verify
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Verify jobs were actually added
        try {
            // First, check Redis directly
            const queueConnection = cityClassificationQueue.opts.connection;
            
            // Check multiple Redis keys to see what's actually there
            const waitKey = 'city-classification:wait';
            const waitCount = await queueConnection.llen(waitKey).catch(() => 0);
            
            // Also check if job IDs exist in Redis
            let foundJobCount = 0;
            for (const jobId of queuedJobIds.slice(0, 5)) { // Check first 5
                try {
                    const jobKey = `city-classification:${jobId}`;
                    const exists = await queueConnection.exists(jobKey);
                    if (exists) foundJobCount++;
                } catch (e) {
                    // Ignore errors
                }
            }
            
            const counts = await cityClassificationQueue.getJobCounts();
            const total = (counts.waiting || 0) + (counts.active || 0) + (counts.completed || 0) + (counts.failed || 0) + (counts.delayed || 0);
            
            console.log(`\nüìä Queue verification:`);
            console.log(`   Jobs queued: ${successCount}`);
            console.log(`   Job IDs collected: ${queuedJobIds.length}`);
            console.log(`   Waiting (BullMQ): ${counts.waiting || 0}`);
            console.log(`   Waiting (Redis direct LLEN): ${waitCount}`);
            console.log(`   Job keys found in Redis: ${foundJobCount}/5 checked`);
            console.log(`   Active: ${counts.active || 0}`);
            console.log(`   Completed: ${counts.completed || 0}`);
            console.log(`   Failed: ${counts.failed || 0}`);
            console.log(`   Delayed: ${counts.delayed || 0}`);
            console.log(`   Total (BullMQ): ${total}`);
            
            // Try to get a few jobs directly
            const sampleJobs = await cityClassificationQueue.getWaiting(0, 5).catch(() => []);
            console.log(`   Sample waiting jobs (getWaiting): ${sampleJobs.length}`);
            
            if (total === 0 && waitCount === 0 && successCount > 0) {
                console.log(`\n‚ö†Ô∏è  WARNING: Jobs were queued but not found in queue!`);
                console.log(`   This could indicate:`);
                console.log(`   1. Jobs were processed immediately by a worker`);
                console.log(`   2. Redis connection issue (different instance/database)`);
                console.log(`   3. Queue name mismatch`);
                console.log(`   4. Jobs were added but immediately removed`);
                console.log(`   5. Redis eviction policy removed the keys`);
                
                // Check Redis eviction policy
                try {
                    const maxmemory = await queueConnection.config('GET', 'maxmemory-policy');
                    console.log(`\n   Redis eviction policy: ${maxmemory[1] || 'unknown'}`);
                    if (maxmemory[1] && maxmemory[1] !== 'noeviction') {
                        console.log(`   ‚ö†Ô∏è  WARNING: Redis eviction policy is "${maxmemory[1]}"`);
                        console.log(`   ‚ö†Ô∏è  BullMQ requires "noeviction" policy to prevent job loss`);
                        console.log(`   üí° Fix with: redis-cli CONFIG SET maxmemory-policy noeviction`);
                    }
                } catch (e) {
                    // Ignore
                }
                
                // Check if cities were actually classified in the database
                console.log(`\nüîç Checking database to see if cities were classified...`);
                const classifiedCount = await CityMetadata.countDocuments({
                    source: 'gpt',
                    processingStatus: 'completed',
                    processedAt: { $gte: new Date(Date.now() - 60000) } // Last minute
                });
                
                if (classifiedCount > 0) {
                    console.log(`   ‚úÖ Found ${classifiedCount} cities classified in the last minute!`);
                    console.log(`   ‚úÖ Jobs WERE processed successfully by a worker`);
                } else {
                    console.log(`   ‚ùå No cities classified in the last minute`);
                    console.log(`   ‚ö†Ô∏è  Jobs were queued but NOT processed`);
                    console.log(`   üí° The worker needs to be running to process jobs.`);
                    console.log(`   üí° If your server is running, the worker should start automatically.`);
                    console.log(`   üí° Otherwise, start the worker manually:`);
                    console.log(`      node server/workers/cityClassificationWorker.js`);
                }
            } else if (waitCount > 0 && total === 0) {
                console.log(`\n‚ö†Ô∏è  WARNING: Jobs found in Redis (${waitCount}) but BullMQ counts show 0!`);
                console.log(`   This suggests a BullMQ connection or state issue.`);
                console.log(`   Jobs are in Redis and should be processed by the worker.`);
            } else if (waitCount > 0 || total > 0) {
                console.log(`\n‚úÖ Jobs are waiting in the queue (${waitCount} in Redis, ${counts.waiting} via BullMQ)`);
                console.log(`   The worker should process them automatically.`);
            }
        } catch (error) {
            console.error(`\n‚ùå Error verifying queue:`, error.message);
            console.error(`   Stack:`, error.stack);
        }
        
        // Release lock before exiting
        if (lockAcquired) {
            await releaseLock(lockKey);
            console.log('‚úÖ Released backfill lock');
        }
        
        process.exit(0);
        
    } catch (error) {
        console.error('‚ùå Error during backfill:', error);
        
        // Release lock on error
        if (lockAcquired) {
            await releaseLock(lockKey);
            console.log('‚úÖ Released backfill lock after error');
        }
        
        process.exit(1);
    }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    backfillCityMetadata();
}

export default backfillCityMetadata;

