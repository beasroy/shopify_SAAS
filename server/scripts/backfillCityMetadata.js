import dotenv from 'dotenv';
import { connectDB } from '../config/db.js';
import { cityClassificationQueue } from '../config/shopifyQueues.js';
import Order from '../models/Order.js';
import CityMetadata from '../models/CityMetadata.js';

dotenv.config();

/**
 * One-time script to backfill CityMetadata for all existing cities in Orders
 * Usage: node server/scripts/backfillCityMetadata.js
 */
async function backfillCityMetadata() {
    try {
        console.log('üîÑ Starting city metadata backfill...');
        
        // Connect to database
        await connectDB();
        console.log('‚úÖ Connected to database');
        
        // Get all unique city/state from Orders
        console.log('üìä Fetching all unique cities from Orders...');
        const allCities = await Order.aggregate([
            {
                $match: {
                    city: { $exists: true, $ne: null, $ne: '' },
                    state: { $exists: true, $ne: null, $ne: '' }
                }
            },
            {
                $group: {
                    _id: {
                        city: { $toLower: { $trim: { input: "$city" }}},
                        state: { $toLower: { $trim: { input: "$state" }}}
                    },
                    originalCity: { $first: "$city" },
                    originalState: { $first: "$state" }
                }
            },
            {
                $project: {
                    _id: 0,
                    cityNormalized: "$_id.city",
                    city: "$originalCity",
                    state: "$originalState"
                    // Note: lookupKey will be generated by GPT/worker with country
                }
            }
        ]);
        
        console.log(`üìä Found ${allCities.length} unique cities`);
        
        if (allCities.length === 0) {
            console.log('‚ÑπÔ∏è  No cities found in Orders table');
            process.exit(0);
        }
        
        // Check existing cities by cityNormalized + state (since lookupKey includes country from GPT)
        // We'll match on city+state combination to avoid duplicates
        const existing = await CityMetadata.find({}).select('cityNormalized state');
        const existingCityStateSet = new Set(
            existing.map(c => `${c.cityNormalized.toLowerCase()}_${c.state.toLowerCase()}`)
        );
        
        const newCities = allCities.filter(c => {
            const cityStateKey = `${c.cityNormalized}_${c.state.toLowerCase()}`;
            return !existingCityStateSet.has(cityStateKey);
        });
        console.log(`üÜï ${newCities.length} new cities to classify (${allCities.length - newCities.length} already exist)`);
        
        if (newCities.length === 0) {
            console.log('‚úÖ All cities already classified');
            process.exit(0);
        }
        
        // Queue batch jobs
        const batchSize = 20;
        let batchNumber = 1;
        const totalBatches = Math.ceil(newCities.length / batchSize);
        
        console.log(`üì¶ Creating ${totalBatches} batch jobs...`);
        
        for (let i = 0; i < newCities.length; i += batchSize) {
            const batch = newCities.slice(i, i + batchSize);
            
            await cityClassificationQueue.add('classify-cities-batch', {
                type: 'batch',
                cities: batch,
                batchNumber: batchNumber++,
                totalBatches: totalBatches
            }, {
                priority: 1,
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 2000
                }
            });
            
            console.log(`‚úÖ Queued batch ${batchNumber - 1}/${totalBatches} (${batch.length} cities)`);
        }
        
        console.log(`\n‚úÖ Backfill complete! Queued ${totalBatches} batch jobs`);
        console.log('‚ÑπÔ∏è  Monitor the queue to see job progress');
        
        // Wait a bit to ensure jobs are queued
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        process.exit(0);
        
    } catch (error) {
        console.error('‚ùå Error during backfill:', error);
        process.exit(1);
    }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    backfillCityMetadata();
}

export default backfillCityMetadata;

